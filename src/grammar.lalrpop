use crate::ast::*;
use crate::memory::{Value, ValueType};

grammar;

pub ProgramBlock: ProgramBlock = {
    Statement* => ProgramBlock { statements: <> },	
}

pub Block: Block = {
	<statements:Statement*> <expression:ExpressionWithoutBlock?> => Block {
		statements,
		expression: expression.map(|e| Box::new(e)),
	},
}

pub Statement: Statement = {
    <lo:@L> <statement:_Statement> <hi:@R> => Statement {
        statement,
        span: Span::new(lo, hi),
    }
}

_Statement: _Statement = {
    LetStatement => <>,
	ExpressionStatement => <>,
}

LetStatement: _Statement = {
	"let" <ident:Ident> (":" ValueType)? "=" <val:Expression> ";" => _Statement::Let(ident, val),
}

ExpressionStatement: _Statement = {
	<ExpressionWithoutBlock> ";" => _Statement::Expression(<>),
	<ExpressionWithBlock> ";"? => _Statement::Expression(<>),
}

pub Expression: Expression = {
	ExpressionWithBlock => <>,
	ExpressionWithoutBlock => <>,
}

pub ExpressionWithoutBlock: Expression = {
	<lo:@L> <expression:_ExpressionWithoutBlock> <hi:@R> => Expression {
        expression,
        span: Span::new(lo, hi),
    },
}

pub ExpressionWithBlock: Expression = {
    <lo:@L> <expression:_ExpressionWithBlock> <hi:@R> => Expression {
        expression,
        span: Span::new(lo, hi),
    }
}

T0: _Expression = {
	"(" <_Expression> ")" => <>,
}

T1: _Expression = {
	<lo:@L> "*" <expr:_Expression> <hi:@R> => _Expression::Dereferece(
		Box::new(
			Expression {
				expression: expr,
				span: Span::new(lo, hi),
			}
		)
	),
	<lo:@L> "&" <expr:_Expression> <hi:@R> => _Expression::Reference(
		Box::new(
			Expression {
				expression: expr,
				span: Span::new(lo, hi),
			}
		)
	),
	T0 => <>,
}

_Expression: _Expression = {
	_ExpressionWithBlock => <>,
	_ExpressionWithoutBlock => <>,
}

_ExpressionWithoutBlock: _Expression = {
    Literal => _Expression::Literal(<>),	
	<lo:@L> <ident:Ident> <hi:@R> => _Expression::Dereferece(
		Box::new(
			Expression { 
				expression: _Expression::Variable(ident),  
				span: Span::new(lo, hi),
			}
		)
	),
	T1 => <>,
}

_ExpressionWithBlock: _Expression = {	
	"{" <Block> "}" => _Expression::Block(<>),
}

pub Literal: Value = {
    r"-?[0-9]+\.[0-9]+" => Value::F32(<>.parse().unwrap()),

    r"-?[0-9]+" => Value::I32(<>.parse().unwrap()),

    r#""[^"]*""# => Value::String(<>[1..<>.len() - 1].to_string()),
}

pub Path: Path = {
    <modules:(<Ident> "::")*> <target:Ident> => {
        Path {
            modules,
            target,
        }
    }
}

Ident: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
}

ValueType: ValueType = {
	"i32" => ValueType::I32,
	"f32" => ValueType::F32,
	"str" => ValueType::String,
	"(" ")" => ValueType::Null,
	"&" <ValueType> => ValueType::Ref(Box::new(<>)),
	"dyn" <mut vec:(<Ident> "+")+> <last:Ident> => {
		vec.push(last);

		ValueType::TraitObject(vec)
	}
}
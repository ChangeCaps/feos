use crate::ast::*;
use crate::memory::{Value, ValueType};

grammar;

pub ProgramBlock: ProgramBlock = {
    Statement* => ProgramBlock { statements: <> },	
}

Block: Block = {
	<statements:Statement*> <expression:Expression> => Block {
		statements,
		expression: Some(Box::new(expression)),
	},
}

UnitBlock: Block = {
	<statements:Statement*> => Block {
		statements,
		expression: None,
	}
}

Statement: Statement = {
    <lo:@L> <statement:_Statement> <hi:@R> => Statement {
        statement,
        span: Span::new(lo, hi),
    }
}

_Statement: _Statement = {
    LetStatement => <>,
	ExpressionStatement => <>,
}

LetStatement: _Statement = {
	"let" <ident:Ident> (":" ValueType)? "=" <val:Expression> ";" => _Statement::Let(ident, val),
}

ExpressionStatement: _Statement = {
	<Expression> ";" => _Statement::Expression(<>),
	<ExpressionWithUnitBlock> => _Statement::Expression(<>),
}

Expression: Expression = {
	ExpressionWithBlock => <>,
	ExpressionWithoutBlock => <>,
}

T0: Expression = {
	"(" <Expression> ")" => <>,

	<lo:@L> <lit:Literal> <hi:@R> => Expression {
		expression: _Expression::Literal(lit),	
		span: Span::new(lo, hi),
	},

	<lo:@L> <ident:Ident> <hi:@R> => Expression { 
		expression: _Expression::Dereferece(
			Box::new(
				Expression { 
					expression: _Expression::Variable(ident),  
					span: Span::new(lo, hi),
				}
			)
		),
		span: Span::new(lo, hi),
	}
}

T1: Expression = {
	<lo:@L> "*" <expr:T1> <hi:@R> => Expression {
		expression: _Expression::Dereferece(Box::new(expr)),
		span: Span::new(lo, hi),
	},

	<lo:@L> "&" <expr:T1> <hi:@R> => Expression {
		expression: _Expression::Reference(Box::new(expr)),
		span: Span::new(lo, hi),
	},

	<lo:@L> "!" <expr:T1> <hi:@R> => Expression {
		expression: _Expression::Not(Box::new(expr)),
		span: Span::new(lo, hi),
	},

	T0 => <>,
}

T2: Expression = {
	<lo:@L> <lhs:T2> "==" <rhs:T1> <hi:@R> => Expression {
		expression: _Expression::Equal(Box::new(lhs), Box::new(rhs)),	
		span: Span::new(lo, hi),
	},

	<lo:@L> <lhs:T2> "!=" <rhs:T1> <hi:@R> => Expression {
		expression: _Expression::Not(
			Box::new(Expression {
				expression: _Expression::Equal(Box::new(lhs), Box::new(rhs)),	
				span: Span::new(lo, hi),
			})
		),
		span: Span::new(lo, hi),
	},

	T1 => <>,
}

T3: Expression = {
	<lo:@L> <target:T3> "=" <value:T2> <hi:@R> => Expression {
		expression: _Expression::Assign(Box::new(target), Box::new(value)),
		span: Span::new(lo, hi),
	},

	T2 => <>
}

ExpressionWithoutBlock: Expression = {
	T3 => <>,
}

BlockExpression: Expression = {
	<lo:@L> "{" <block:Block> "}" <hi:@R> => Expression {
		expression: _Expression::Block(block),
		span: Span::new(lo, hi),
	},
}

IfExpression: Expression = {
	<lo:@L> "if" <check:Expression> <block:BlockExpression> "else" <else_block:BlockExpression> <hi:@R> => Expression {
		expression: _Expression::If(Box::new(check), Box::new(block), Some(Box::new(else_block))),
		span: Span::new(lo, hi),
	},

	<lo:@L> "if" <check:Expression> <block:BlockExpression> "else" <else_block:IfExpression> <hi:@R> => Expression {
		expression: _Expression::If(Box::new(check), Box::new(block), Some(Box::new(else_block))),
		span: Span::new(lo, hi),
	},
}

ExpressionWithBlock: Expression = {
	BlockExpression => <>,	
	IfExpression => <>,
}

UnitBlockExpression: Expression = {
	<lo:@L> "{" <block:UnitBlock> "}" <hi:@R> => Expression {
		expression: _Expression::Block(block),
		span: Span::new(lo, hi),
	},
}

UnitIfExpression: Expression = {
	<lo:@L> "if" <check:Expression> <block:UnitBlockExpression> <hi:@R> => Expression {
		expression: _Expression::If(Box::new(check), Box::new(block), None),
		span: Span::new(lo, hi),
	},

	<lo:@L> "if" <check:Expression> <block:UnitBlockExpression> "else" <else_block:UnitBlockExpression> <hi:@R> => Expression {
		expression: _Expression::If(Box::new(check), Box::new(block), Some(Box::new(else_block))),
		span: Span::new(lo, hi),
	},

	<lo:@L> "if" <check:Expression> <block:UnitBlockExpression> "else" <else_block:UnitIfExpression> <hi:@R> => Expression {
		expression: _Expression::If(Box::new(check), Box::new(block), Some(Box::new(else_block))),
		span: Span::new(lo, hi),
	},
}

ExpressionWithUnitBlock: Expression = {
	UnitBlockExpression => <>,
	UnitIfExpression => <>,
}

pub Literal: Value = {
    r"-?[0-9]+\.[0-9]+" => Value::F32(<>.parse().unwrap()),

    r"-?[0-9]+" => Value::I32(<>.parse().unwrap()),

    r#""[^"]*""# => Value::String(<>[1..<>.len() - 1].to_string()),

	"true" => Value::Bool(true),
	"false" => Value::Bool(false),
}

pub Path: Path = {
    <modules:(<Ident> "::")*> <target:Ident> => {
        Path {
            modules,
            target,
        }
    }
}

Ident: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
}

ValueType: ValueType = {
	"i32" => ValueType::I32,
	"f32" => ValueType::F32,
	"str" => ValueType::String,
	"(" ")" => ValueType::Null,
	"&" <ValueType> => ValueType::Ref(Box::new(<>)),
	"dyn" <mut vec:(<Ident> "+")+> <last:Ident> => {
		vec.push(last);

		ValueType::TraitObject(vec)
	}
}
